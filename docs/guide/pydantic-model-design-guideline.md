# Pydanticモデル設計ガイドライン

## 1. はじめに

### 1.1 目的

本ガイドラインは、プロジェクトにおけるPydanticモデルの設計方針、特にデータ構造定義とビジネスロジックの扱いに関する指針を示します。一貫した設計判断に基づき、コードの品質、保守性、再利用性の向上を目的とします。

### 1.2 対象読者

本プロジェクトの開発に携わるすべての開発者を対象とします。

## 2. Pydanticモデルの基本的な責務

Pydanticモデルは、主に以下の責務を担います。

- データ構造の定義（フィールド、型、ネスト構造など）
- 入力データの検証と変換（型アノテーションに基づく自動的な型変換を含む）
- 外部データ形式（JSON, YAMLなど）との相互変換

## 3. ビジネスロジックの扱いに関する方針

### 3.1 原則: 責務の分離（SRP）

- Pydanticモデルは、原則として上記「2. 基本的な責務」に専念させ、ビジネスロジックは分離します。
- ビジネスロジックは、サービスクラス、ユーティリティ関数、ドメインオブジェクトなど、モデルとは別のコンポーネントに実装することを推奨します。
- 主な理由：
    - 単一責任の原則（SRP）を守ることで、変更の影響範囲を限定し、コードの理解と保守を容易にします。
    - データ構造の検証とビジネスロジックのテストを分離できます。
    - ビジネスロジックを特定のデータ構造（Pydanticモデル）から独立させることで、再利用性が向上します。

### 3.2 例外: 凝集度の優先

- 以下の条件を満たす場合に限り、Pydanticモデルにビジネスロジック（メソッド）を持たせることを許容します。
    1. データ構造とそのデータを操作する手続き（ロジック）が概念的に密接不可分であり、一体として扱うことが自然である。
    2. データとその振る舞いをカプセル化することで、オブジェクト指向設計の原則に合致し、コードの可読性や理解しやすさが向上する。
    3. ロジックをモデルに含めることで、ファクトリパターンなどの変換処理が不要になり、コードがシンプルになるなど、分離する場合と比較して明確なメリットがある。
- この例外を適用する場合でも、モデルの責務が過度に肥大化しないか、テスト容易性が損なわれないかを慎重に検討してください。

## 4. 適用例: バリデーションルールモデル

本プロジェクトのバリデーション機能におけるルール定義モデル（`RuleModel`, `Expression` 派生クラス）は、上記「3.2 例外」を適用する典型的な例です。

- バリデーションルールは、「ルールの定義（データ）」と「そのルールに基づく検証（振る舞い）」から構成されます。
- これらを同じPydanticモデル内に実装することで、凝集度が高まり、オブジェクト指向の原則（カプセル化）にも合致します。
- PydanticのUnion型による自動的な型解決と組み合わせることで、設定データから実行可能なルールオブジェクトへの変換ファクトリが不要になり、コードがシンプルになります。
- 実装例：

```python
class CompareExpression(Expression):
    compare: Dict[str, Any]
    def validate(self, context: ValidationContext, error_message_template: str) -> ValidationResult:
        # ... 比較ロジック ...
        pass

class RuleModel(BaseModel):
    name: str
    expression: ExpressionType # Union型
    error_message: str
    def validate(self, context: ValidationContext) -> ValidationResult:
        return self.expression.validate(context, self.error_message)
```

## 5. 判断基準と考慮事項

Pydanticモデルにビジネスロジックを含めるかどうかの最終判断は、以下の点を総合的に考慮して行います。

- 凝集度：データとロジックは、概念的にどの程度強く結びついているか？一体と見なすのが自然か？
- 責務の肥大化：ロジックを追加することで、モデルの責務が過度に多くなり、複雑化しないか？
- テスト容易性：ロジックを含むモデルの単体テストは現実的に可能か？依存関係（例: `ValidationContext`）の注入やモックは容易か？
- 再利用性：そのロジックを、将来的にモデルとは独立した形で再利用する必要があるか？
- Pydanticの主目的との整合性：Pydanticは主にデータ検証ライブラリであり、その設計思想から大きく逸脱していないか？
- コードのシンプルさ：ロジックを含めることで、全体としてコードがよりシンプルかつ直感的になるか？（例: ファクトリが不要になる）

## 6. 結論

Pydanticモデルの設計においては、原則としてデータ構造定義とビジネスロジックの分離（SRP）を推奨します。しかし、データとロジックの凝集度が非常に高く、それらを一体として扱うことで明確なメリット（コードのシンプル化、オブジェクト指向原則への適合など）が得られる場合には、例外的にロジックの同梱を許容します。

どちらの方針を採用する場合でも、その判断理由を明確にし、必要であれば設計ドキュメントやコードコメントに記載してください。

---
最終更新日: 2025年4月19日
